<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Justin Holewinski - Windows</title>
	<link href="https://jholewinski.github.io/tags/windows/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://jholewinski.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2012-11-06T00:00:00+00:00</updated>
	<id>https://jholewinski.github.io/tags/windows/atom.xml</id>
	<entry xml:lang="en">
		<title>2012 and still no multi-monitor lovin&#x27;...</title>
		<published>2012-11-06T00:00:00+00:00</published>
		<updated>2012-11-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://jholewinski.github.io/blog/2012-and-still-no-multi-monitor-lovin/" type="text/html"/>
		<id>https://jholewinski.github.io/blog/2012-and-still-no-multi-monitor-lovin/</id>
		<content type="html">&lt;p&gt;For the past week, I&#x27;ve been giving Windows 8 a serious try. I&#x27;ve dabbled with
the various preview versions, but now it&#x27;s time to try the released version.
I&#x27;ve read the reviews, saw the mixed reactions to the new &amp;quot;Modern UI&amp;quot;, and
decided to see for myself how I feel about it. Generally speaking, I don&#x27;t mind
the new interface. My usual method of launching a program was pressing the Win
key, typing the first few letters of the application name, and then hitting
Enter. Still works in the Start Screen. Start Menu vs. Start Screen, it doesn&#x27;t
bother me. Except for one little detail...&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;... the complete lack of multi-monitor support in the Modern UI!&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Simply put, there can only be one full-screen Modern UI app displayed at a time.
So if I open, say, Mail on one screen and attempt to open Maps on another
screen, the screen showing Mail will go back to the desktop. To make matters
worse, the Start Screen counts as a Modern UI app in this regard. If I have Mail
open on one screen and try to open the Start Screen on another screen to launch
an application, the screen showing Mail goes back to the desktop and I have to
alt+tab back to it. Talk about a disruption in my workflow!&lt;&#x2F;p&gt;
&lt;p&gt;Did I mention my main desktop is triple-head? It comes in handy for coding. All
of the Windows 8 reviews I read talk about the pros and cons of the new Modern
UI, but I rarely see any reference to the complete lack of multi-monitor support
in it. I&#x27;m not sure if this is just a feature oversight, or a more fundamental
limitation in the model used for WinRT apps. Is there a fundamental technical
limitation in the operating system that prevents multiple Modern UI apps to be
visible at the same time? If the Modern UI is the future, I sure hope they get
this fixed ASAP! For now, it&#x27;s easy enough to just avoid Modern UI apps
altogether, but what happens in the future when I find an app I want to keep
open on one of my screens?&lt;&#x2F;p&gt;
&lt;p&gt;Perhaps more disturbing, this is becoming a trend in mainstream operating
systems. While Windows 8 has this limitation for Modern UI apps, full-screen
apps in Mac OS X are not really any better. If I full-screen an application in a
multi-monitor configuration, I get that app on one monitor and a pretty
background on all others. I would much rather have the ability to put multiple
apps in full-screen mode side-by-side, or perhaps have the option to have a
full-screen app next to a desktop workspace on another monitor. At least I can
have multiple workspaces, though.&lt;&#x2F;p&gt;
&lt;p&gt;Perhaps I&#x27;m just too adjusted to my Linux multi-monitor configurations...&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Space Hogs Binary Release</title>
		<published>2012-02-17T00:00:00+00:00</published>
		<updated>2012-02-17T00:00:00+00:00</updated>
		<link rel="alternate" href="https://jholewinski.github.io/blog/space-hogs-binary-release/" type="text/html"/>
		<id>https://jholewinski.github.io/blog/space-hogs-binary-release/</id>
		<content type="html">&lt;p&gt;I&#x27;ve converted my old Space Hogs game project to XNA 4.0 (it was originally
written in XNA 1.0). There were enough API changes to make it a pain, but I
think I have everything working now.&lt;&#x2F;p&gt;
&lt;p&gt;This game was developed by myself, Jason Kim, Joseph Ahn, Vjekoslav Kovacevic,
and Daniel Guinn for a computer animation class during Winter Quarter 2007.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;spacehogs-screen1.png&quot; alt=&quot;Screenshot&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can find a zip file &lt;a href=&quot;&#x2F;binaries&#x2F;SpaceHogs.zip&quot;&gt;here&lt;&#x2F;a&gt;. This requires XNA 4.0
and the February 2010 DX packages to be installed on your machine. For
convenience, I&#x27;ve included both of the redistributable packages in the zip file.&lt;&#x2F;p&gt;
&lt;p&gt;Enjoy!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Direct3d 11 With Qt 4</title>
		<published>2012-02-16T00:00:00+00:00</published>
		<updated>2012-02-16T00:00:00+00:00</updated>
		<link rel="alternate" href="https://jholewinski.github.io/blog/direct3d-11-with-qt-4/" type="text/html"/>
		<id>https://jholewinski.github.io/blog/direct3d-11-with-qt-4/</id>
		<content type="html">&lt;p&gt;(If you&#x27;re in a hurry, the full source can be found on my &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;bitbucket.org&#x2F;jholewinski&#x2F;qt4-d3d11&quot;&gt;Bitbucket&lt;&#x2F;a&gt; account)&lt;&#x2F;p&gt;
&lt;p&gt;When it comes to GUI frameworks for C++, it&#x27;s very hard to beat Qt.
It&#x27;s modular, easy to use, and available on practically any desktop
system (and even a few mobile systems).  The MOC&#x27;ing can get a bit
annoying, but IDE and command-line support is very mature at this point.
However, only OpenGL is supported currently for real-time 3D rendering.
If you want to render to a Qt widget from a Direct3D 11 device, you end
up having to do a lot of setup yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, there is not a lot of information out on the internet
about setting up Direct3D to play nice with Qt.  Most of the information
is either out-dated, or only applies to Direct3D 9.  Lately, I&#x27;ve been
playing around with this and I want to share my method for combining
Direct3D 11 and Qt.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;qtd3d11-screen1.png&quot; alt=&quot;Screenshot&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;creating-a-widget&quot;&gt;Creating a Widget&lt;&#x2F;h1&gt;
&lt;p&gt;To start, we define a new widget sub-class specifically for Direct3D 11
rendering. On the Qt side, the key to eliminating flickering or UI
artifacts is the &lt;code&gt;paintEngine()&lt;&#x2F;code&gt; method.  We need a way to tell Qt
that we want complete control over drawing for our widget, so we can
override &lt;code&gt;paintEngine()&lt;&#x2F;code&gt; in our widget definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span&gt;D3DRenderWidget : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;QWidget &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;     Q_OBJECT
&lt;&#x2F;span&gt;&lt;span&gt;     Q_DISABLE_COPY(D3DRenderWidget)
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;     D3DRenderWidget(QWidget&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;parent = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;virtual &lt;&#x2F;span&gt;&lt;span&gt;~D3DRenderWidget();
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;virtual&lt;&#x2F;span&gt;&lt;span&gt; QPaintEngine&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;paintEngine() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return NULL&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;protected&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span&gt;resizeEvent(QResizeEvent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;evt);
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span&gt;paintEvent(QPaintEvent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;evt);
&lt;&#x2F;span&gt;&lt;span&gt;   };
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Note that for ease of viewing, all of the fields have been removed from
this code snippet)&lt;&#x2F;p&gt;
&lt;p&gt;We also need to set a few attributes on our widget, as shown in the
constructor:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;   D3DRenderWidget::D3DRenderWidget(QWidget&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;parent)
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;QWidget(parent) {
&lt;&#x2F;span&gt;&lt;span&gt;     setAttribute(Qt::WA_PaintOnScreen, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;     setAttribute(Qt::WA_NativeWindow, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2F;&#x2F; Create Device
&lt;&#x2F;span&gt;&lt;span&gt;     createDevice();
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, we tell Qt that we do not want it to do any draw buffering for
us. Second, we require a native window handle for our widget. Otherwise,
Qt may re-use the same native handle for multiple widgets and cause
problems for our Direct3D rendering. You may have also noticed the
&lt;code&gt;createDevice()&lt;&#x2F;code&gt; method call; this will be explained in a bit.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;creating-the-direct3d-11-device&quot;&gt;Creating the Direct3D 11 Device&lt;&#x2F;h1&gt;
&lt;p&gt;Now that we have a basic widget that can support Direct3D rendering, we
can initialize the Direct3D 11 device we want. This procedure is mostly
identical to setting up Direct3D in a raw window. The only difference is
that we must use the &lt;code&gt;width()&lt;&#x2F;code&gt;, &lt;code&gt;height()&lt;&#x2F;code&gt;, and &lt;code&gt;winId()&lt;&#x2F;code&gt; methods
to return the widget size and native window handle, respectively:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;   swapChainDesc_.BufferCount = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferDesc.Width = width();
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferDesc.Height = height();
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.SampleDesc.Count = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.SampleDesc.Quality = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.Windowed = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.OutputWindow = winId();
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferDesc.RefreshRate.Numerator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;60&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   swapChainDesc_.BufferDesc.RefreshRate.Denominator = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything else remains the same... pretty easy, huh? :)&lt;&#x2F;p&gt;
&lt;h1 id=&quot;handling-paint-events&quot;&gt;Handling Paint Events&lt;&#x2F;h1&gt;
&lt;p&gt;Remember the &lt;code&gt;paintEvent&lt;&#x2F;code&gt; override from the widget class definition?
We can simply implement it with a call to some rendering function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;D3DRenderWidget::paintEvent(QPaintEvent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;evt) {
&lt;&#x2F;span&gt;&lt;span&gt;     render();
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;render()&lt;&#x2F;code&gt; is just some arbitrary method that uses the Direct3D
11 device to render something to the primary swap chain.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;handling-resize-events&quot;&gt;Handling Resize Events&lt;&#x2F;h1&gt;
&lt;p&gt;Resize events are perhaps the hardest events to handle when integrating
Direct3D 11 and Qt. To resize our swap chain, we need to release all
device-allocated resources, and reallocate them. The procedure I follow
is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1e1e1e;color:#dcdcdc;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;D3DRenderWidget::resizeEvent(QResizeEvent&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;evt) {
&lt;&#x2F;span&gt;&lt;span&gt;     releaseBuffers();
&lt;&#x2F;span&gt;&lt;span&gt;     swapChain_-&amp;gt;ResizeBuffers(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, width(), height(), swapChainDesc_.BufferDesc.Format, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;     swapChain_-&amp;gt;GetDesc(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;swapChainDesc_);
&lt;&#x2F;span&gt;&lt;span&gt;     viewport_.Width = width();
&lt;&#x2F;span&gt;&lt;span&gt;     viewport_.Height = height();
&lt;&#x2F;span&gt;&lt;span&gt;     createBuffers();
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We start by releasing all of the buffers we had allocated (vertex
buffers, index buffers, shaders, textures, etc.). We then issue a resize
request to the swap chain, resize our rendering viewport, and then
recreate all of our needed buffers. In this snippet,
&lt;code&gt;releaseBuffers()&lt;&#x2F;code&gt; will call &lt;code&gt;Release()&lt;&#x2F;code&gt; on all buffers, and
&lt;code&gt;createBuffers()&lt;&#x2F;code&gt; will create all of the needed resources (again).&lt;&#x2F;p&gt;
&lt;p&gt;It would probably be easier to just allow the swap chain to grow and
just adjust the viewport if the widget shrinks, but this method shows
how to keep the swap chain the exact same size as the widget.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;At this point, you should have a functional Direct3D 11 rendering
context for a Qt widget. For brevity, I have omitted most of the
Direct3D initialization code (this can be found in many places on the
web).&lt;&#x2F;p&gt;
&lt;p&gt;If you want to check out the complete sample program, it is located on
my &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;bitbucket.org&#x2F;jholewinski&#x2F;qt4-d3d11&quot;&gt;BitBucket&lt;&#x2F;a&gt; account.
To build it, you need a relatively recent Qt
release, the DirectX SDK, and the Qt Visual Studio Add-in.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
